package service

import (
	"github.com/gogo/protobuf/proto"
	"github.com/hyperledger/fabric/sdk"
	"strconv"
	"strings"
)

type SetupRequest struct {
	// 网络名称
	NetworkName string `json:"networkName"`
	// 共识模式
	Consensus string `json:"consensus"`
	// 组织名称
	OrgName string `json:"orgName"`
	// 组织别名
	OrgAlias string `json:"orgAlias"`
	// peer 端口
	PeerPorts []PeerPorts `json:"peerPorts"`
	// orderer 端口
	OrdererPorts []OrdererPorts `json:"ordererPorts"`
	// 公司名称
	Company string `json:"company"`
	// 证书是否自动生成 现在只支持true
	AutoGeneratedCerts bool `json:"autoGeneratedCerts"`
}

type PeerPorts struct {
	Main      uint32 `json:"main"`
	Chaincode uint32 `json:"chaincode"`
	Event     uint32 `json:"event"`
	Block     uint32 `json:"block"`
}

type OrdererPorts struct {
	Main  uint32 `json:"main"`
	Raft  uint32 `json:"raft"`
	Debug uint32 `json:"debug"`
}

func GetBuildInfo(setupReq *SetupRequest) *BuildInfo {
	endpoint := "192.168.9.67"

	peers := []*PeerInfo{}
	for i, peerPorts := range setupReq.PeerPorts {
		peerName := Name(i, "peer", setupReq.OrgName)
		logger.Debug("peerName: ", peerName)
		labelsPeer := make(map[string]string)
		labelsPeer["nodename"] = peerName
		peers = append(peers, &PeerInfo{
			ID:     peerName,
			Labels: labelsPeer,
			MainPort: PortMapping{
				Port:             peerPorts.Main,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(peerPorts.Main))}, ":"),
			},
			ChaincodePort: PortMapping{
				Port:             peerPorts.Chaincode,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(peerPorts.Chaincode))}, ":"),
			},
			EventPort: PortMapping{
				Port:             peerPorts.Event,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(peerPorts.Event))}, ":"),
			},
			BlockPort: PortMapping{
				Port:             peerPorts.Block,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(peerPorts.Block))}, ":"),
			},
			Public: true,
		})
	}

	orderer := []*OrdererInfo{}
	for i, ordererPorts := range setupReq.OrdererPorts {
		ordererName := Name(i, "orderer", setupReq.OrgName)
		logger.Debug("ordererName: ", ordererName)
		labelsOrderer := make(map[string]string)
		labelsOrderer["nodename"] = ordererName
		orderer = append(orderer, &OrdererInfo{
			ID:     ordererName,
			Labels: labelsOrderer,
			MainPort: PortMapping{
				Port:             ordererPorts.Main,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(ordererPorts.Main))}, ":"),
			},
			RaftPort: PortMapping{
				Port:             ordererPorts.Raft,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(ordererPorts.Raft))}, ":"),
			},
			Debugserverport: PortMapping{
				Port:             ordererPorts.Debug,
				ExternalEndpoint: strings.Join([]string{endpoint, strconv.Itoa(int(ordererPorts.Debug))}, ":"),
			},
		})
	}
	build := &BuildInfo{
		PeerInfo:    peers,
		OrdererInfo: orderer,
		Consensus:   setupReq.Consensus,
	}
	return build
}

func Name(index int, instancetype string, orgname string) string {
	var res string

	if orgname == "" {
		orgname = "baas1"
	}
	res = strings.Join([]string{instancetype, strconv.Itoa(index), strings.ToLower(orgname)}, "-")

	return res
}

func CreateGenesisBlockData(orgMSP string, orgCA *sdk.CA, info *BuildInfo, kafkas []string, consensus string) ([]byte, error) {

	peerOrg := &sdk.Organization{
		Name:   orgMSP,
		ID:     orgMSP,
		MSPDir: orgCA.MSPDir(),
	}

	ordererOrg := &sdk.Organization{
		Name:   orgMSP,
		ID:     orgMSP,
		MSPDir: orgCA.MSPDir(),
	}

	conf := &sdk.GenesisConfig{
		ChainID:                 sdk.DefaultSystemChainID,
		OrdererType:             consensus,
		Addresses:               info.Orderers(),
		AdminsPolicy:            sdk.PolicyMajorityAdmins,
		WritersPolicy:           sdk.PolicyAnyWriters,
		ReadersPolicy:           sdk.PolicyAnyReaders,
		OrdererOrganizations:    []*sdk.Organization{ordererOrg},
		ConsortiumOrganizations: []*sdk.Organization{peerOrg},
		ConsortiumName:          sdk.DefaultConsortium,
		KafkaBrokers:            kafkas,
	}

	block := sdk.CreateGenesisBlock(conf)
	return proto.Marshal(block)

}

//
//func GetCA(dir string, msp string) (*sdk.CA, error) {
//	info, err := os.Stat(dir)
//	if os.IsNotExist(err) {
//		return sdk.NewCA(dir, msp)
//	}
//	if err == nil {
//		if !info.IsDir() {
//			return nil, errors.New("msp path is not a directory, but a file")
//		}
//		return sdk.ConstructCAFromDir(dir)
//	}
//	return nil, err
//}
